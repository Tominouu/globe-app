<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>360 Capture Web - Front Only</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <h3>Capture 360 (Front Only)</h3>
  <video id="video" autoplay playsinline></video>
  <div id="guide">OK</div>
  <div>
    <button id="snap">Prendre photo</button>
    <button id="stitch">Assembler Panorama</button>
  </div>
  <div id="thumbs"></div>
  <canvas id="snapCanvas" width="640" height="480"></canvas>
  <canvas id="canvasResult"></canvas>

  <!-- OpenCV.js -->
  <script async src="https://docs.opencv.org/4.x/opencv.js" type="text/javascript"></script>

<script>
const video = document.getElementById('video');
const canvas = document.getElementById('snapCanvas');
const ctx = canvas.getContext('2d');
const snaps = [];
const thumbs = document.getElementById('thumbs');
const resultCanvas = document.getElementById('canvasResult');

// start camera
async function startCam(){
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" }, audio:false });
    video.srcObject = stream;
  } catch(e) {
    alert("Impossible d'accéder à la caméra: " + e.message);
  }
}
startCam();

// guidage simple
const guide = document.getElementById('guide');
window.addEventListener('deviceorientation', (ev) => {
  const b = ev.beta || 0;
  const g = ev.gamma || 0;
  if (Math.abs(b) < 30 && Math.abs(g) < 30) {
    guide.classList.add('ok');
    guide.textContent = 'OK';
  } else {
    guide.classList.remove('ok');
    guide.textContent = 'TILT';
  }
});

// redimensionnement simple pour éviter les images trop grandes
async function resizeBlob(blob, maxSize=1024){
  return new Promise(resolve=>{
    const img = new Image();
    img.onload = () => {
      const scale = Math.min(maxSize/img.width, maxSize/img.height,1);
      canvas.width = img.width*scale;
      canvas.height = img.height*scale;
      ctx.drawImage(img,0,0,canvas.width,canvas.height);
      canvas.toBlob(resolve,'image/jpeg',0.9);
    };
    img.src = URL.createObjectURL(blob);
  });
}

// capture
document.getElementById('snap').addEventListener('click', async () => {
  const w = video.videoWidth || 640;
  const h = video.videoHeight || 480;
  canvas.width = w;
  canvas.height = h;
  ctx.drawImage(video, 0, 0, w, h);
  canvas.toBlob(async blob=>{
    const resized = await resizeBlob(blob);
    snaps.push(resized);
    const img = document.createElement('img');
    img.src = URL.createObjectURL(resized);
    thumbs.appendChild(img);
  },'image/jpeg',0.9);
});

// stitching front-only avec OpenCV.js
document.getElementById('stitch').addEventListener('click', async () => {
  if (snaps.length < 2) { alert("Prends au moins 2 photos"); return; }

  // attendre que OpenCV soit prêt
  if (typeof cv === 'undefined' || !cv.Mat) {
    alert("OpenCV.js pas encore chargé, attends quelques secondes.");
    return;
  }

  let mats = [];
  for (let blob of snaps) {
    const img = await createImageBitmap(blob);
    canvas.width = img.width;
    canvas.height = img.height;
    ctx.drawImage(img,0,0);
    let mat = cv.imread(canvas);
    mats.push(mat);
  }

  try {
    let stitcher = new cv.Stitcher();
    let pano = new cv.Mat();
    let status = stitcher.stitch(mats, pano);
    if (status !== cv.Stitcher_OK) {
      alert("Stitching échoué : " + status);
      mats.forEach(m=>m.delete());
      pano.delete();
      return;
    }

    cv.imshow(resultCanvas, pano);

    mats.forEach(m=>m.delete());
    pano.delete();
  } catch(e) {
    console.error(e);
    alert("Erreur stitching : " + e.message);
  }
});
</script>
</body>
</html>
